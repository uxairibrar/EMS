from flask import Flask, request, jsonify, abortfrom flask_sqlalchemy import SQLAlchemyfrom sqlalchemy import CheckConstraintfrom datetime import datetimefrom faker import Fakerfrom sqlalchemy.sql.expression import funcimport pandas as pdfrom sklearn.linear_model import LinearRegressionfrom sklearn.compose import ColumnTransformerfrom sklearn.preprocessing import OneHotEncoderfrom sklearn.model_selection import train_test_splitapp = Flask(__name__)app.secret_key="Secret Key"app.config['SQLALCHEMY_DATABASE_URI']='sqlite:///employees.sqlite3'app.config["SQLALCHEMY_TRACK_MODIFICATIONS"]=Falseapp.app_context().push()db=SQLAlchemy(app)#     ----------         SQLAlchemy Employee Model Classclass Employee(db.Model):    __tablename__ = 'employees'    id=db.Column(db.Integer,primary_key=True, autoincrement=True)    name=db.Column(db.String(50))    department=db.Column(db.String(50))    salary = db.Column(db.Float, CheckConstraint('salary >= 0 AND salary <= 1000000'))    hire_date = db.Column(db.DateTime, CheckConstraint('hire_date BETWEEN "2020-01-01 00:00:00" AND :now', deferrable=True))    @classmethod    def __declare_last__(cls):        cls.now = datetime.utcnow  # Set the now variable to the current UTC datetime    def __repr__(self):        return f'<Employee:{self.name}>'#    -----------         Utilserror_messages = {    'invalid_id': 'Invalid Employee ID',    'data_missing': 'Employee Data Missing',    'emoloyee_not_found':'Employee Not Found',    'department_not_found':'Department Not Found'}fake = Faker()def randomData():    for i in range(5):        name = fake.name()        department = fake.job()        salary = fake.pyfloat(min_value=0, max_value=1000000, right_digits=2)        hire_date = fake.date_time_between(start_date='-2y', end_date='now')        employee = Employee(name=name, department=department, salary=salary, hire_date=hire_date)        db.session.add(employee)        db.session.commit()# APIs# It's an index page will just return the response that whether the API's are functional or not@app.route('/')def Index():    return "Hello Flask Application"# Returns a list of all employees in the database@app.route('/employees', methods=['GET'])def get_employees():    employees = Employee.query.all()    data=[{'id': e.id, 'name': e.name, 'department': e.department, 'salary': e.salary, 'hire_date': e.hire_date} for e in employees]    return jsonify(                    message=f"{len(data)} total no of employees",                    category="success",                    data=data,                    status=200                 )# Returns the employee with the specified ID.@app.route('/employees/<int:id>', methods=['GET'])def get_employee(id):    employee = Employee.query.filter_by(id=id).first()    if not employee:        abort(404, error_messages['invalid_id'])    data={'id': employee.id, 'name': employee.name, 'department': employee.department, 'salary': employee.salary, 'hire_date': employee.hire_date}    return jsonify(                   category="success",                   data=data,                   status=200                )# Creates a new employee with the specified data (name, department, salary, hire_date). The API should return the ID of the newly created employee.@app.route('/employees', methods=['POST'])def create_employee():    data = request.get_json()    if not all(key in data for key in ['name', 'department', 'salary', 'hire_date']):        abort(404, error_messages['data_missing'])    employee = Employee(name=data['name'], department=data['department'], salary=data['salary'], hire_date=datetime.strptime(data['hire_date'], '%Y-%m-%d %H:%M:%S'))    try:        db.session.add(employee)        db.session.commit()        return jsonify(            message= 'Employee added successfully',            category="success",            data={'id': employee.id},            status=200        )    except:        db.session.rollback()        return jsonify(            error='Failed to add employee',            status=500        )# Updates the employee with the specified ID with the specified data (name, department, salary, hire_date).@app.route('/employees/<int:id>', methods=['PUT'])def update_employee(id):    employee = Employee.query.get(id)    if not employee:        return jsonify(            error=error_messages['emoloyee_not_found'],            status=404        )    data = request.get_json()    if not data:        return jsonify(            error=error_messages['data_missing'],            status=400        )    if 'name' in data:        employee.name = data['name']    if 'department' in data:        employee.department = data['department']    if 'salary' in data:        employee.salary = data['salary']    if 'hire_date' in data:        employee.hire_date = data['hire_date']    try:        db.session.commit()        return jsonify(            message='Employee updated successfully',            category="success",            status=200        )    except:        db.session.rollback()        return jsonify(            error='Failed to update employee',            status=500        )# Deletes the employee with the specified ID.@app.route('/employees/<int:id>', methods=['DELETE'])def delete_employee(id):    employee = Employee.query.get(id)    if not employee:        return jsonify(            error=error_messages['emoloyee_not_found'],            status=404        )    try:        db.session.delete(employee)        db.session.commit()        return jsonify(            message='Employee deleted successfully',            category="success",            status=200        )    except:        db.session.rollback()        return jsonify(            error='Failed to delete employee',            status=500        )# Returns a list of all unique departments in the database.@app.route('/departments', methods=['GET'])def get_departments():    departments = Employee.query.with_entities(Employee.department).distinct().all()    department_list = [d[0] for d in departments]    return jsonify(        message=f"{len(department_list)} total no of departments",        category="success",        data={'departments':department_list},        status=200    )# Returns a list of all employees in the specified department.@app.route('/departments/<string:name>', methods=['GET'])def get_department_employees(name):    print(name)    employees = Employee.query.filter_by(department=name).all()    if not employees:        return jsonify(            error=error_messages['department_not_found'],            status=404        )    employees_list = [        {'id': e.id, 'name': e.name, 'department': e.department, 'salary': e.salary, 'hire_date': e.hire_date} for e in        employees]    return jsonify(        message=f" No of employees in a department are {len(employees_list)}",        category="success",        data={'departments': employees_list},        status=200    )# Returns the average salary of employees in the specified department.@app.route('/average_salary/<string:department>', methods=['GET'])def get_average_salary(department):    avg_salary = db.session.query(func.avg(Employee.salary)).filter_by(department=department).scalar()    if not avg_salary:        return jsonify(            error=error_messages['department_not_found'],            status=404        )    return jsonify(        category="success",        data={'average_salary': round(avg_salary, 2)},        status=200    )# Returns a list of the top 10 earners in the company based on their salary.@app.route('/top_earners', methods=['GET'])def get_top_earners():    employees = Employee.query.order_by(Employee.salary.desc()).limit(10).all()    employees_list = [        {'id': e.id, 'name': e.name, 'department': e.department, 'salary': e.salary, 'hire_date': e.hire_date} for e in        employees]    return jsonify(            category="success",            data={'employees': employees_list},            status=200        )# Returns a list of the 10 most recently hired employees.@app.route('/most_recent_hires', methods=['GET'])def get_most_recent_hires():    employees = Employee.query.order_by(Employee.hire_date.desc()).limit(10).all()    employees_list = [        {'id': e.id, 'name': e.name, 'department': e.department, 'salary': e.salary, 'hire_date': e.hire_date} for e in        employees]    return jsonify(        category="success",        data={'employees': employees_list},        status=200    )# Takes in data for a new employee (department, hire date, and job title) and returns the predicted salary.@app.route('/predict_salary', methods=['POST'])def predict_salary():    employees = Employee.query.all()    df = pd.DataFrame([(e.department, e.hire_date, e.name, e.salary) for e in employees],                      columns=['department', 'hire_date', 'name', 'salary'])    df['hire_date'] = pd.to_datetime(df['hire_date'])    df['hire_date'] = (df['hire_date'] - datetime(2020, 1, 1)).dt.days    department_encoder = OneHotEncoder()    transformer = ColumnTransformer(transformers=[('dept', department_encoder, ['department'])],                                    remainder='passthrough')    X = transformer.fit_transform(df[['department', 'hire_date']])    y = df['salary']    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)    model = LinearRegression()    model.fit(X_train, y_train)    data = request.get_json()    data = request.get_json()    if not data:        return jsonify(            error=error_messages['data_missing'],            status=400        )    department = data['department']    hire_date_str = data['hire_date']    hire_date = (datetime.strptime(hire_date_str, '%Y-%m-%d %H:%M:%S') - datetime(2020, 1, 1)).days    data = dict(department=department, hire_date=hire_date)    df = pd.DataFrame(data, index=[0])    X_new = transformer.transform(df[['department', 'hire_date']])    salary_pred = model.predict(X_new)[0]    return jsonify(            category="success",            data={'predicted_salary': salary_pred},            status=200        )if(__name__=="__main__"):    db.create_all()    randomData()    app.run(debug=True)